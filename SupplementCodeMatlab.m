
% Description:
% This document gives two function. The first one is for equations (7), (10), (12) and (13) presented in the paper "Distributional Properties of Continuous Time Processes: From CIR to Bates".
% It thus calculates the (un)conditional (co)moments of the solution of the CIR process.
% The second function calculates the first four unconditonal moments as well as the skewness and kurtosis for log-returns arising from the SVJD model presented in the paper "Distributional Properties of Continuous Time Processes: From CIR to Bates".
%
% Abstract:
% We focus on returns defined as log-price differentials and generated by a diffusion process with stochastic volatility and jumps in prices.
% The jumps are properly compensated for this model. The stochastic volatility within this model follows the well-known CIR process.
% We present general conditional and unconditional (co-)moment formulas for the solution of this process.
% By identifying these moments with those of a non-central chi-squared distribution, we derive distributional properties in a way that signifcantly differs from the historic approaches.
% Next, we derive the conditional and unconditional characteristic functions of log-returns which allows us to generate conditional and unconditional moments.
% We provide closed form expressions for the first four unconditional moments of log-returns.
%
%
% Parameters of the functions:
% p is the order of (un)conditional moments and the first order of (un)conditional comoments
% q is the second order of (un)conditional comoments (Default 0, only required if comoments are computed)
% kappa is a CIR process parameter and controls the speed of mean reversion (must be > 0)
% theta is a CIR process parameter and controls the long-run mean (must be > 0)
% sigma is a CIR process parameter and controls the volatility (must be > 0)
% rho is a Bates process parameter and controls the correlation between spot variance and (log-)price at time t (must be >= -1 and <= 1)
% lambda is a Bates process parameter and controls the jump intensity (must be >= 0)
% muj is a Bates process parameter and controls the expected jump size in log-prices
% vj is a Bates process parameter and controls the jump size variance in log-prices (must be >= 0)
% t is the time index. For log-return moments, it is the time passed between two log-prices used to calculate the return (must be > 0)
% v0 is the starting value of the CIR process (must be > 0)
% conditional is a Boolean which controls if conditional or unconditional (co)moments of the CIR process solution are computed (Default: TRUE)
% comoments is a Boolean which controls if moments or comoments of the CIR process solution are computed (Default: FALSE)
clc, close all, clear all

fprintf('Authors: Ostap Okhrin, Michael Rockinger, Manuel Schmid \n')
fprintf('Date: Tue, February 21 2020 \n')


fprintf('\nExamples: \n \n')


p = (1:4)';
q = 0;
kappa = 3;
theta = 0.19;
sigma = 0.4;
v0    = 0.1;
dt    = 1/250;
conditional = true;
comoments   = false;

fprintf('\n')
fprintf('  Compute first 4 conditional moments of v_t\n')
MomentsCIR(p, q, kappa, theta, sigma, v0, dt, conditional, comoments)

conditional = false;
comoments   = false;

fprintf('\n')
fprintf('  Compute first 4 unconditional moments v_t\n')
MomentsCIR(p,  q, kappa, theta, sigma, v0, dt, conditional, comoments)

q=(1:4)';
conditional = true;
comoments   = true;

fprintf('\n')
fprintf('  Compute all combination of (p,q)-th conditonal comoment v_t\n')
MomentsCIR(p, q, kappa, theta, sigma, v0, dt, conditional, comoments)

conditional = false;
comoments   = true;
fprintf('\n')
fprintf('  Compute all combination of (p,q)-th unconditonal comoment v_t\n')
MomentsCIR(p, q, kappa, theta, sigma, v0, dt, conditional, comoments)


mu = 0;
kappa = 3;
theta = 0.19;
sigma = 0.4;
rho = -0.7;
lambda = 20;
muj = 0;
vj = 0.1;
dt = 1/250;

fprintf('\n')
fprintf('\n')
fprintf('Compute first four unconditonal moments as well as skewness and kurtosis for t-year log-returns\n')
MomentsBates(mu, kappa, theta, sigma, rho, lambda, muj, vj, dt )



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


function x = aFun(p, kappa, v0)
x = v0.^(p - 1)./kappa;
end

function x = bFun(kappa, t)
x = exp(kappa .* t) - 1;
end

function x = cFun(p, kappa, theta, sigma)
x = (p - 1) .* (kappa .* theta + 0.5 .* (p - 2) .* sigma.^2);
end

function x = IFun(k, kappa, t)
x = bFun(kappa, t).^k ./ (factorial(k) .* kappa.^(k-1));
% transform this into gama for large k
end

function res = mFun(k, p, kappa, theta, sigma, v0)
res = zeros(length(k),1);
for i = 1:length(k)
    if (k(i) == 0)
        res(i) = 0;
    else
        res(i) = aFun(p - k(i), kappa, v0) * prod( cFun(((p - k(i) + 1):p)', kappa, theta, sigma));
    end
end
end

function x = nuFun (p, kappa, theta, sigma, v0, t)
x = aFun(p, kappa, v0) .* bFun(kappa, t) + sum(mFun( (0:(p - 1))', p, kappa, theta, sigma, v0) .* IFun((1:p)', kappa, t));
end

function [res, namesres] = Evp_v0_A(p, kappa, theta, sigma, v0, t)
res = zeros(length(p),1);
namesres = cell(length(p),1);
for i = 1:length(p)
    res(i) = exp(-p(i) * kappa * t) * (v0^p(i) + cFun(p(i) + 1, kappa, theta, sigma) * nuFun(p(i), kappa, theta, sigma, v0, t));
    namesres{i} = strcat("Evt^",num2str(p(i)),"|v0");
end
end

function res = Evp_v0_B(p, kappa, theta, sigma, v0, t)
res = zeros(length(p),1);
for i =1:length(p)
    res(i) = exp(-p(i) * kappa * t) * (v0^p(i) + cFun(p(i) + 1, kappa, theta, sigma) * nuFun(p(i), kappa, theta, sigma, v0, t));
end
end


function [res,colnames,rownames]=Evpvq_v0(p, q, kappa, theta, sigma, v0, t)
res = zeros(length(p), length(q));
colnames=cell(length(q),1);
rownames=cell(length(p),1);
for i = 1:length(p)
    for j = 1:length(q)
        res(i,j) = v0^p(i) * Evp_v0_B(q(j), kappa, theta, sigma, v0, t);
        colnames{j} = strcat("q = ", num2str(q(j)));
        rownames{i} = strcat("p = ", num2str(p(i)));
    end
end
end

function [res, namesres] = Evp_A(p, kappa, theta, sigma, v0)
res = zeros(length(p),1);
namesres=cell(length(p),1);
for i = 1:length(p)
    if p(i) == 1
        res(i) = cFun(2, kappa, theta, sigma) * aFun(1, kappa, v0);
    else
        res(i) = cFun(p(i) + 1, kappa, theta, sigma) * mFun(p(i) - 1, p(i), kappa, theta, sigma, v0) / (factorial(p(i)) * kappa^(p(i) - 1));
    end
    namesres{i}= strcat("Evt^",num2str(p(i)));
end
end

function res = Evp_B(p, kappa, theta, sigma, v0)
res = zeros(length(p),1);
for i = 1:length(p)
    if p(i) == 1
        res(i) = cFun(2, kappa, theta, sigma) * aFun(1, kappa, v0);
    else
        res(i) = cFun(p(i) + 1, kappa, theta, sigma) * mFun(p(i) - 1, p(i), kappa, theta, sigma, v0) / (factorial(p(i)) * kappa^(p(i) - 1));
    end
end
end

function res = Evp_m(k, p, q, kappa, theta, sigma, v0, t)
res = zeros(length(k), 1);
for i = 1:length(k)
    if k(i) == 0
        res(i) = 0;
    else
        res(i) = Evp_B(p + q - k(i) - 1, kappa, theta, sigma, v0) / kappa * prod(cFun(((q - k(i) + 1):q)', kappa, theta, sigma));
    end
end
end

function x = Evp_nuq(p, q, kappa, theta, sigma, v0, t)
x = Evp_B(p+q-1, kappa, theta, sigma, v0) .* bFun(kappa, t) ./ kappa + sum(Evp_m((0:(q-1))', p , q, kappa, theta, sigma, v0).*IFun((1:q)', kappa, t));
end

function [res, rownames, colnames] = Evpvq(p, q, kappa, theta, sigma, v0, t)
res = zeros( length(p), length(q));
rownames = cell(length(p),1);
colnames = cell(length(q),1);
for i = 1:length(p)
    for j = 1:length(q)
        res(i,j) = exp(-q(j) * kappa * t) * (Evp_B(p(i) + q(j), kappa, theta, sigma, v0) + cFun(q(j) + 1, kappa, theta, sigma) * Evp_nuq(p(i), q(j), kappa, theta, sigma, v0, t));
        colnames{j} = strcat("q = ", num2str(q(j)));
        rownames{i} = strcat("p = ", num2str(p(i)));
    end
end
end



function MomentsCIR(p, q, kappa, theta, sigma, v0, t, conditional, comoments)

if conditional && ~comoments
    
    [res, namesres] = Evp_v0_A(p, kappa, theta, sigma, v0, t);
    for k=1:length(res)
        fprintf('%20s %16.10f\n',namesres{k},res(k))
    end
    
elseif conditional && comoments
    
    [res,colnames,rownames] = Evpvq_v0(p, q, kappa, theta, sigma, v0, t);
    for i=1:size(res,1)
        for j=1:size(res,2)
            fprintf('%16.10f  ',res(i,j))
        end
        fprintf('\n')
    end
    
    
elseif ~conditional && ~comoments
    
    [res, namesres] = Evp_A(p, kappa, theta, sigma, v0);
    for k=1:length(res)
        fprintf('%20s %16.10f\n',namesres{k},res(k))
    end
    
    
elseif ~conditional && comoments
    
    [res, rownames, colnames] = Evpvq(p, q, kappa, theta, sigma, v0, t);
    for i=1:size(res,1)
        for j=1:size(res,2)
            fprintf('%16.10f  ',res(i,j))
        end
        fprintf('\n')
    end
end
end



%%%%%%%%

function MomentsBates(mu, kappa, theta, sigma, rho, lambda, muj, vj, t)


if(kappa <= 0)
    error("kappa must be > 0");
end
if(theta <= 0)
    error("theta must be > 0");
end
if(sigma <= 0)
    error("sigma must be > 0");
end
if(rho < - 1 || 1 < rho)
    error("rho must be >= -1 or <= 1");
end
if(lambda < 0)
    error("lambda must be >= 0");
end
if(vj < 0)
    error("vj must be >= 0");
end
if(t <= 0)
    error("t must be > 0");
end

Ert1 = (mu - theta / 2) * t;


Ert2 = (sigma * (- 4 * kappa * rho + sigma) * theta + exp(kappa * t) * (- (sigma^2 * theta) - 4 * kappa^2 * rho * sigma * t * theta + kappa * sigma * (4 * rho + sigma * t) * theta + ...
    kappa^3 * t * (4 * theta + t * (-2 * mu + theta)^2 + lambda * vj * (4 + vj)) + 4 * kappa^3 * lambda * t * log(1 + muj) * (-vj + log(1 + muj)))) / (4 * exp(kappa * t) * kappa^3);


Ert3 =  (- 3 * sigma * theta * (2 * sigma^3 + kappa * sigma^2 * (- 12 * rho + sigma * t) + 4 * kappa^3 * rho*(- 2 + 2 * mu * t + 2 * rho * sigma * t - t * theta) + ...
    kappa^2 * sigma * (4 + 16 * rho^2 - 2 * mu * t - 6 * rho * sigma * t + t * theta)) + ...
    exp(kappa * t) * (6 * sigma^4 * theta - 3 * kappa * sigma^3 * (12 * rho + sigma * t) * theta + 12 * kappa^4 * rho * sigma * t * theta * (2 - 2 * mu * t + t * theta) + ...
    3 * kappa^2 * sigma^2 * theta * (4 + 16 * rho^2 - 2 * mu * t + 6 * rho * sigma * t + t * theta) - ...
    3 * kappa^3 * sigma * theta * (8 * rho^2 * sigma * t + sigma * t * (4 - 2 * mu * t + t * theta) + rho * (8 - 8 * mu * t + 4 * t * theta)) + ...
    kappa^5 * t * (t * (2 * mu - theta) * (12 * theta + t * (- 2 * mu + theta)^2) + 12 * lambda * t * (2 * mu - theta) * vj + 3 * lambda * (- 4 + 2 * mu * t - t * theta) * vj^2 - ...
    lambda * vj^3)) + 2 * exp(kappa * t) * kappa^5 * lambda * t * log(1 + muj) * ...
    (3 * vj * (4 - 4 * mu * t + 2 * t * theta + vj) - 6 * (-2 * mu * t + t * theta + vj) * log(1 + muj) + 4 * log(1 + muj)^2)) / (8 * exp(kappa * t) * kappa^5);



Ert4 = (( - 24 * kappa^2 * (2 * kappa * rho - sigma) * sigma * t * (2 * (- 1 + exp(kappa * t)) * sigma^2 - kappa * sigma * (8 * (- 1 + exp(kappa * t)) * rho + sigma * t) ...
    + 4 * kappa^2 * (- 1 + exp(kappa * t) + rho * sigma * t)) * (2 * mu - theta) * theta)/exp(kappa * t) + (3 * sigma^2 * theta * ((-4 * kappa*rho + sigma)^2 * ...
    (sigma^2 + 2 * kappa * theta) + exp(2 * kappa * t) * (- 32 * kappa^4 * (1 + 8 * rho^2) - 29 * sigma^4 + 2 * kappa * sigma^2 * (116 * rho * sigma + theta) - ...
    16 * kappa^2 * sigma * (6 * sigma + 35 * rho^2 * sigma + rho * theta) + 32 * kappa^3 * rho * (12 * (1 + rho^2) * sigma + rho * theta)) - ...
    4 * exp(kappa * t) * (- 7 * sigma^4 + 16 * kappa^5 * rho^2 * t * (-2 + rho * sigma * t) + 4 * kappa^4 * (- 2 + rho * (12 * sigma*t + ...
    rho * (- 16 + sigma * t * (16 * rho - 5 * sigma * t)))) + kappa * sigma^2 * (56 * rho * sigma - 5 * sigma^2 * t + theta) - ...
    kappa^2 * sigma * (sigma * (24 + 136 * rho^2 - 40 * rho * sigma * t + sigma^2 * t^2) + 8 * rho * theta) + ...
    4 * kappa^3 * (sigma * (24 * (rho + rho^3) - 3 * (1 + 8 * rho^2) * sigma * t + 2 * rho * sigma^2 * t^2) + 4 * rho^2 * theta))))/ ...
    exp(2 * kappa * t) + (12 * (- 1 + exp(kappa * t)) * kappa^2 * (4 * kappa * rho - sigma) * sigma * t * theta * (- 4 * kappa * rho * sigma * theta + ...
    sigma^2 * theta + kappa^2 * (4 * theta + t * (- 2 * mu + theta)^2 + lambda * vj * (4 + vj)) + 4 * kappa^2 * lambda * log(1 + muj) * (- vj + log(1 + muj)))) / exp(kappa * t) + ...
    2 * kappa * t * (- 120 * kappa * rho * sigma^5 * theta + 15 * sigma^6 * theta - 48 * kappa^3 * rho * sigma^3 * theta * (6 + 4 * rho^2 - 3 * mu * t + 2 * t * theta) + ...
    3 * kappa^2 * sigma^4 * theta * (24 + 96 * rho^2 - 8 * mu * t + 5 * t * theta) + kappa^6 * (t * (16 * mu^4 * t^2 - 32 * mu^2 * t * (- 3 + mu * t) * theta + ...
    24 * (2 + mu * t * (- 4 + mu * t)) * theta^2 - 8 * t * (- 3 + mu * t) * theta^3 + t^2 * theta^4) + 24 * lambda * t * (4 * theta + t * (- 2 * mu + theta)^2) * vj + ...
    6 * lambda * (8 + t * (8 * lambda + 4 * mu^2 * t - 4 * mu*(4 + t * theta) + theta * (12 + t * theta))) * vj^2 + 4 * lambda * (6 + t * (6 * lambda - 2 * mu + theta)) * vj^3 + ...
    lambda * (1 + 3 * lambda * t) * vj^4) - 24 * kappa^5 * rho * sigma * t * theta * (4 * mu^2 * t - 4 * mu * (2 + t * theta) + theta * (8 + t * theta) + lambda * vj * (4 + vj)) + ...
    6 * kappa^4 * sigma^2 * theta * (8 - 16 * mu * t + 8 * rho^2 * (4 - 4 * mu * t + 3 * t * theta) + t * (12 * theta + t * (- 2 * mu + theta)^2 + lambda * vj * (4 + vj))) + ...
    8 * kappa^4 * lambda * log(1 + muj) * (vj * (12 * kappa * rho * sigma * t * theta - 3 * sigma^2 * t * theta + ...
    kappa^2 * (- 12 * mu^2 * t^2 - 3 * t * theta * (8 + t * theta) - 3 * (4 + 4 * lambda * t + t * theta) * vj - (1 + 3 * lambda * t) * vj^2 + ...
    6 * mu * t*(4 + 2 * t * theta + vj))) + log(1 + muj) * (3 * (- 4 * kappa * rho * sigma * t * theta + sigma^2 * t * theta + ...
    kappa^2 * (t * (4 * theta + t * (-2 * mu + theta)^2) + 2 * (2 + t * (2 * lambda - 2 * mu + theta)) * vj + (1 + 3 * lambda * t) * vj^2)) + ...
    2 * kappa^2 * log(1 + muj) * (- 2 * (vj + t * (- 2 * mu + theta + 3 * lambda * vj)) + (1 + 3 * lambda * t) * log(1 + muj)))))) / (32 * kappa^7);



Skewrt = (- 3 * (2 * kappa * rho - sigma) * sigma * (- 2 * sigma^2 + kappa * sigma * (8 * rho - sigma * t) + 4 * kappa^2 * (- 1 + rho * sigma * t)) * theta - ...
    exp(kappa * t) * (- 3 * (2 * kappa * rho - sigma) * sigma * (- 2 * sigma^2 + 4 * kappa^3 * t + kappa * sigma * (8 * rho + sigma * t) - ...
    4 * kappa^2 * (1 + rho * sigma * t)) * theta + 12 * kappa^5 * lambda * t * vj^2 + kappa^5 * lambda * t * vj^3) + ...
    2 * exp(kappa * t) * kappa^5 * lambda * t * log(1 + muj) * (3 * vj * (4 + vj) - 6 * vj * log(1 + muj) + 4 * log(1 + muj)^2)) / ...
    (exp(kappa * t) * kappa^5 * (((- 1 + exp(- kappa * t)) * sigma^2 * theta - 4 * kappa^2 * rho * sigma * t * theta + ...
    kappa * sigma * ((4 - 4 / exp(kappa * t)) * rho + sigma * t) * theta + kappa^3 * t * (4 * theta + lambda * vj * (4 + vj))) / kappa^3 - ...
    4 * lambda * t * vj * log(1 + muj) + 4 * lambda * t * log(1 + muj)^2)^1.5);



Kurtrt = (3 * sigma^2 * (- 4 * kappa * rho + sigma)^2 * theta * (sigma^2 + 2 * kappa * theta) + 12 * exp(kappa * t) * sigma * theta * (7 * sigma^5 - ...
    kappa * sigma^3 * (56 * rho*sigma - 5 * sigma^2 * t + theta) + kappa^2 * sigma^2 * (- 40 * rho * sigma^2 * t + sigma^3 * t^2 + ...
    8 * rho * theta + sigma * (24 + 136 * rho^2 + t * theta)) - 4 * kappa^3 * sigma * (24 * rho^3 * sigma - 3 * sigma^2 * t + 4 * rho^2 * (- 6 * sigma^2 * t + theta) + ...
    2 * rho * sigma * (12 + sigma^2 * t^2 + t * theta)) - 4 * kappa^5 * rho * t * (- 8 * rho * sigma + 4 * rho^2 * sigma^2 * t + 4 * theta + lambda * vj * (4 + vj)) + ...
    kappa^4 * sigma * (8 - 48 * rho * sigma * t - 64 * rho^3 * sigma * t + 4 * rho^2 * (16 + 5 * sigma^2 * t^2 + 4 * t * theta) + t * (4 * theta + lambda * vj * (4 + vj)))) + ...
    exp(2 * kappa * t) * (- 87 * sigma^6 * theta + 6 * kappa * sigma^4 * theta * (116 * rho * sigma + 5 * sigma^2 * t + theta) + 6 * kappa^3 * sigma^2 * theta * (192 * rho^3 * sigma + ...
    16 * rho^2 * (6 * sigma^2 * t + theta) + 16 * rho * sigma * (12 + t * theta) + sigma^2 * t * (24 + t*theta)) - 12 * kappa^2 * sigma^3 * theta * (20 * rho * sigma^2 * t + ...
    4 * rho * theta + sigma * (24 + 140 * rho^2 + t * theta)) - 48 * kappa^6 * rho * sigma * t^2 * theta * (4 * theta + lambda * vj * (4 + vj)) - ...
    12 * kappa^4 * sigma^2 * theta * (8 + 32 * rho^3 * sigma * t + 16 * rho^2 * (4 + t * theta) + 4 * rho * sigma * t * (12 + t * theta) + ...
    t * (4 * theta + lambda * vj * (4 + vj))) + 2 * kappa^7 * t * (lambda * vj^2 * (48 + 24 * vj + vj^2) + 3 * t * (4 * theta + lambda * vj * (4 + vj))^2) + ...
    12 * kappa^5 * sigma * t * theta * (4 * rho * (4 * theta + lambda * vj * (4 + vj)) + sigma * (8 + 8 * rho^2 * (4 + t * theta) + t * (4 * theta + lambda * vj * (4 + vj))))) - ...
    16 * exp(kappa * t) * kappa^4 * lambda * t * vj * (- 3 * (- 1 + exp(kappa * t)) * sigma^2 * theta - 12 * exp(kappa * t) * kappa^2 * rho * sigma * t * theta + ...
    3 * kappa * sigma * (4 * (- 1 + exp(kappa * t)) * rho + exp(kappa * t) * sigma * t) * theta + exp(kappa * t) * kappa^3 * (vj * (12 + vj) + ...
    3 * t * (4 * theta + lambda * vj * (4 + vj)))) * log(1 + muj) + 48 * exp(kappa * t) * kappa^4 * lambda * t * ((1 - exp(kappa * t)) * sigma^2 * theta - ...
    4 * exp(kappa * t) * kappa^2 * rho * sigma * t * theta + kappa * sigma * (4 * (- 1 + exp(kappa * t)) * rho + exp(kappa * t) * sigma * t) * theta + ...
    exp(kappa * t) * kappa^3 * (vj * (4 + vj) + t * (4 * theta + lambda * vj * (4 + 3 * vj)))) * log(1 + muj)^2 - ...
    64 * exp(2 * kappa * t) * kappa^7 * lambda * t * (1 + 3 * lambda * t) * vj * log(1 + muj)^3 + 32 * exp(2 * kappa * t) * kappa^7 * lambda * t * (1 + 3 * lambda * t) * log(1 + muj)^4) /...
    (2 * exp(2 * kappa * t) * kappa^7 * (((- 1 + exp(- kappa * t)) * sigma^2 * theta - 4 * kappa^2 * rho * sigma * t * theta + ...
    kappa * sigma * ((4 - 4 / exp(kappa * t)) * rho + sigma * t) * theta + kappa^3 * t * (4 * theta + lambda * vj * (4 + vj))) / kappa^3 - 4 * lambda * t * vj * log(1 + muj) + ...
    4 * lambda * t * log(1 + muj)^2)^2);


res = [Ert1, Ert2, Ert3, Ert4, Skewrt, Kurtrt];
namesres = ["Ert", "Ert2", "Ert3", "Ert4", "Skewrt", "Kurtrt"];


for k=1:length(res)
    fprintf('%20s %16.10f\n',namesres{k},res(k))
end

end
